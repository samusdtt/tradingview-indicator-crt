// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © samusdtt

// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © harrysam11

// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © Zeiierman

//@version=5
indicator("HTF Candle and Seperetor",overlay = true,max_bars_back = 500, max_boxes_count = 500)

// ~~ Inputs {
tf       = input.timeframe("60","Timeframe", group="Higher Timeframe Candles")
numb     = input.int(4,"Amount of Candles",minval=0, maxval=20, group="Higher Timeframe Candles")+1
dn_col   = input.color(color.new(color.red,10), title="Dn", inline="Candles", group="Higher Timeframe Candles")
dn_wick  = input.color(color.new(color.red,0), title="Wick", inline="Candles", group="Higher Timeframe Candles")
up_col   = input.color(color.new(color.lime,10), title="Up",inline="Candles", group="Higher Timeframe Candles")
up_wick  = input.color(color.new(color.lime,0), title="Wick", inline="Candles", group="Higher Timeframe Candles")
Range    = input.bool(false,"Range High/Low", inline="range", group="Range")
Mid      = input.bool(true,"Range Mid", inline="range", group="Range")
high_col = input.color(color.red, title="High", inline="range 1", group="Range")
low_col  = input.color(color.lime, title="Low",inline="range 1", group="Range")
mid_col  = input.color(color.rgb(20, 69, 246), title="Mid",inline="range 1", group="Range")
loc      = input.int(1,"Location", group="Location Settings")

// ~~ Table Inputs {
showTable      = input.bool(true,title="Show Table", inline="tbl", group="Table")
TblSize        = input.string(size.normal,title="",options=[size.auto,size.tiny,size.small,size.normal,size.large,size.huge],inline="tbl", group="Table")
pos            = input.string(position.top_right, title="",options =[position.top_right,position.top_center,
 position.top_left,position.bottom_right,position.bottom_center,position.bottom_left,position.middle_right,position.middle_left],inline="tbl", group="Table")
textcolor      = input.color(color.white, title="Text",inline="tbl_col", group="Table")
bgcolor        = input.color(color.new(color.blue,30), title="Bg",inline="tbl_col", group="Table")
//~~~}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ HTF Error Message {
tfs = str.tonumber(tf)
if str.tostring(tf) == "1D"
    tfs := 1440 
error = str.tonumber(timeframe.period)>=tfs
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ UDT {
type HTF
    array<box> candle
    array<line> wickH
    array<line> wickL
    array<float> hl  
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Variables {
b = bar_index
var candle    = HTF.new(array.new<box>(numb),array.new<line>(numb),array.new<line>(numb),array.new<float>(numb*2))
[o,h,l,c]     = request.security(syminfo.ticker,tf,[open,high,low,close],lookahead=barmerge.lookahead_on)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Code {
if ta.change(o) //New candle declaration
    candle.candle.shift().delete()
    candle.wickH.shift().delete()
    candle.wickL.shift().delete()
    candle.hl.shift()
    candle.hl.shift()

    candle.candle.push(box.new(b+numb*4+loc,math.max(o,c),b+numb*4+loc+2,math.min(o,c),color(na),bgcolor=o>c?dn_col:up_col))
    candle.wickH.push(line.new(b+numb*4+loc+1,math.max(o,c),b+numb*4+loc+1,h,color=o>c?dn_col:up_col))
    candle.wickL.push(line.new(b+numb*4+loc+1,math.min(o,c),b+numb*4+loc+1,l,color=o>c?dn_col:up_col))
    candle.hl.push(h)
    candle.hl.push(l)
else // Relocate previous & current candles
    d = loc
    for [i,x] in candle.candle
        if i<numb-1
            x.set_left(b+d*2)
            x.set_right(b+d*2+2)
            candle.wickH.get(i).set_x1(b+d*2+1)
            candle.wickH.get(i).set_x2(b+d*2+1)
            candle.wickL.get(i).set_x1(b+d*2+1)
            candle.wickL.get(i).set_x2(b+d*2+1)
        else
            x.set_lefttop(b+d*2,math.max(o,c))
            x.set_rightbottom(b+d*2+2,math.min(o,c))
            x.set_bgcolor(o>c?dn_col:up_col)
            candle.wickH.get(i).set_xy1(b+d*2+1,math.max(o,c))
            candle.wickH.get(i).set_xy2(b+d*2+1,h)
            candle.wickH.get(i).set_color(o>c?dn_wick:up_wick)
            candle.wickL.get(i).set_xy1(b+d*2+1,math.min(o,c))
            candle.wickL.get(i).set_xy2(b+d*2+1,l)
            candle.wickL.get(i).set_color(o>c?dn_wick:up_wick)
            candle.hl.set(numb*2-2,h)
            candle.hl.set(numb*2-1,l)
        d += 2
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Range {
if Range
    RangeHigh  = line.new(b,candle.hl.max(),b+numb*4+loc+2,candle.hl.max(),color=high_col,extend=extend.none)
    RangeLow   = line.new(b,candle.hl.min(),b+numb*4+loc+2,candle.hl.min(),color=low_col,extend=extend.none)
    (RangeHigh[1]).delete()
    (RangeLow[1]).delete()

if Mid    
    RangeMid = line.new(b,math.avg(candle.hl.max(),candle.hl.min()),b+numb*4+loc+2,math.avg(candle.hl.max(),candle.hl.min()),color=mid_col,extend=extend.none)
    (RangeMid[1]).delete()

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}
// ~~ Table { 
tbl            = table.new(pos, 2, 11, frame_color=chart.bg_color, frame_width=2, border_width=2, border_color=chart.bg_color)
if barstate.islast and showTable
    tbl.cell(0, 0, text=error?"Error":"TF", text_color=textcolor, bgcolor=bgcolor, text_size=TblSize)
    tbl.cell(0, 1, text=error?"The chart's timeframe must be less than the HTF '"+tf+"' timeframe. \n\nor please select a higher timeframe in the setting panel of the indicator.":str.tostring(timeframe.period), text_halign=text.align_center, bgcolor=bgcolor, text_color=textcolor, text_size=TblSize)
    tbl.cell(1, 0, text="HTF", text_color=textcolor, bgcolor=bgcolor, text_size=TblSize)
    tbl.cell(1, 1, text=str.tostring(tf), text_halign=text.align_center, bgcolor=bgcolor, text_color=textcolor, text_size=TblSize)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}


// Inputs
sepColorInput    = input.color   (color.gray,    "Separator Color")
sepStyleInput    = input.string  ("Dotted",      "Separator Style", options = ["Solid", "Dashed", "Dotted"])
sepWidthInput    = input.int     (1,             "Separator Width", minval = 1)
sepTimeframeInput = input.timeframe("60", "Separator Timeframe")  // Timeframe for the separator

// Function to get the line style
getLineStyle(string input) =>
    switch input
        "Solid"  => line.style_solid
        "Dashed" => line.style_dashed
        "Dotted" => line.style_dotted

// Function to draw the period separator
drawPeriodSeparator(color color, string style, int width, string timeframe) =>
    if timeframe.change(timeframe)
        line.new(
             x1     = bar_index,
             x2     = bar_index,
             y1     = high + syminfo.mintick,
             y2     = low,
             extend = extend.both,
             color  = color,
             style  = getLineStyle(style),
             width  = width
             )

// Draw the period separator based on the selected timeframe and visible on the same or lower timeframes
if timeframe.in_seconds(timeframe.period) <= timeframe.in_seconds(sepTimeframeInput)
    drawPeriodSeparator(sepColorInput, sepStyleInput, sepWidthInput, sepTimeframeInput)


// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Sonarlab

_tfSettings = "TimeFrame Settings"
currentTF  = input.bool(true, title = "Liquidity Levels", group=_tfSettings)
htfBool  = input.bool(false, title = "Higher Timeframe",inline="1", group=_tfSettings)
htfTF  = input.timeframe("", title = "", inline="1",group=_tfSettings, tooltip="Display Liquidity Levels for a Higher Timeframe")
// --
_lvlsGrp = "Liquidity Levels"
leftBars  = input.int(15, title = "Left Bars", group=_lvlsGrp, tooltip="Set the lookback point for what determines a Liquidity Level")
rightBars  = input.int(5, title = "Right Bars", group=_lvlsGrp, tooltip="Set the number of bars to confirm a Liquidity Level")
// --
_removeGrp = "Mitigation Settings"
removeMitigated  = input.bool(true, title = "Mitigated", inline="1", group=_removeGrp)
mitiOptions  = input.string("Show", title = "    ",  inline="1", options=["Remove", "Show"], group=_removeGrp, tooltip="Show: Liquidity Levels will stop printing when mitigated and remain on the chart.\nRemove: Liquidity Levels will be removed from the chart when mitigated.")
_candleType  = input.string("Close", title = "Candle type", options=["Close", "Wick"], group=_removeGrp, tooltip="Choose whether a candle close or a candles high/low is needed to determine a mitigated Liquidity Level")
// --
_displayStyleGrp = "Display Styles"
displayStyle  = input.string("Lines", title = "Display Style", options=["Lines", "Boxes"], group=_displayStyleGrp, tooltip="Choose how Liquidity Levels are displayed on the chart")
extentionOptions  = input.string("Current", title = "Extention Options", options=["Short", "Current", "Max"], group=_displayStyleGrp, tooltip="Choose how Liquidity Levels are extended on the chart")
extentionMax = extentionOptions=="Max" ? true : false
extentionCurrent = extentionOptions=="Current" ? true : false
displayLimit  = input.int(5, title = "Display Limit", group=_displayStyleGrp, tooltip="")
// --
_styleGrp = "Line Styles and Colors"
_highLineStyle  = input.string("Solid", title = "High Line Style", options=["Solid", "Dashed", "Dotted"], group=_styleGrp)
highLineStyle = _highLineStyle=="Solid" ? line.style_solid : _highLineStyle=="Dashed" ? line.style_dashed : line.style_dotted
_lowLineStyle  = input.string("Solid", title = "Low Line Style", options=["Solid", "Dashed", "Dotted"], group=_styleGrp)
lowLineStyle = _lowLineStyle=="Solid" ? line.style_solid : _lowLineStyle=="Dashed" ? line.style_dashed : line.style_dotted
lineWidth  = input.int(1, title = "Line Width", group=_styleGrp, tooltip="")

// --
highLineColor = input.color(#1f4ef5, "High Line   ", group = _styleGrp, inline = "1")
lowLineColor = input.color(#fd441c, "Low Line", group = _styleGrp, inline = "1")
highBoxBgColor = input.color(color.new(#1f4ef5, 80), "High Box Bg ", group = _styleGrp, inline = "2")
highBoxBorderColor = input.color(color.new(#1f4ef5, 80), "Box Border", group = _styleGrp, inline = "2")
lowBoxBgColor = input.color(color.new(#fd441c, 80), "Low Box Bg  ", group = _styleGrp, inline = "3")
lowBoxBorderColor = input.color(color.new(#fd441c, 80), "Box Border", group = _styleGrp, inline = "3")
// --
// --
_styleGrpHTF = "Line Styles and Colors - Higher TimeFrame"
_highLineStyleHTF  = input.string("Solid", title = "High Line HTF", options=["Solid", "Dashed", "Dotted"], group=_styleGrpHTF)
highLineStyleHTF = _highLineStyleHTF=="Solid" ? line.style_solid : _highLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted
_lowLineStyleHTF  = input.string("Solid", title = "Low Line HTF", options=["Solid", "Dashed", "Dotted"], group=_styleGrpHTF)
lowLineStyleHTF = _lowLineStyleHTF=="Solid" ? line.style_solid : _lowLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted
lineWidthHTF  = input.int(1, title = "Line Width HTF", group=_styleGrpHTF, tooltip="")

// --
highLineColorHTF = input.color(#4c9650, "High Line   ", group = _styleGrpHTF, inline = "1")
lowLineColorHTF = input.color(#fd1c49, "Low Line", group = _styleGrpHTF, inline = "1")
highBoxBgColorHTF = input.color(color.new(#4c9650, 80), "High Box Bg ", group = _styleGrpHTF, inline = "2")
highBoxBorderColorHTF = input.color(color.new(#4c9650, 80), "Box Border", group = _styleGrpHTF, inline = "2")
lowBoxBgColorHTF = input.color(color.new(#fd1c49, 80), "Low Box Bg  ", group = _styleGrpHTF, inline = "3")
lowBoxBorderColorHTF = input.color(color.new(#fd1c49, 80), "Box Border", group = _styleGrpHTF, inline = "3")

// --
// --
// Alerts
alertNewHigh = input.bool(true, title = "New High", inline="1", group="Alerts")
alertNewHighTxt = input.string("Break out!", title="", inline="1", group="Alerts")

alertNewLow  = input.bool(true, title = "New Low", inline="2", group="Alerts")
alertNewLowTxt = input.string("Break down!", title="", inline="2", group="Alerts")

alertNewHighHTF  = input.bool(true, title = "New HTF High", inline="3", group="Alerts")
alertNewHighHTFTxt = input.string("Break out!", title="", inline="3", group="Alerts")

alertNewLowHTF  = input.bool(true, title = "New HTF Low", inline="4", group="Alerts")
alertNewLowHTFTxt = input.string("Break down!", title="", inline="4", group="Alerts")


// --
// ----------------------------------------------------
// Functions 
// ----------------------------------------------------
tf_multi(tf) =>
    ts = timeframe.in_seconds("")
    htfs = timeframe.in_seconds(tf)
    htfs/ts

display_limit_line(_array) =>
    if array.size(_array) > displayLimit/2
        a = array.shift(_array)
        line.delete(a)

display_limit_box(_array) =>
    if array.size(_array) > displayLimit/2
        a = array.shift(_array)
        box.delete(a)

remove_mitigated_lines(_array, _hl) =>
    m = false
    if array.size(_array) > 0 and removeMitigated        
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = _candleType == "Close" ? close[1] : high
            ll = _candleType == "Close" ? close[1] : low
            if _hl == "High" and hh > line.get_y1(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = color.new(highLineColor, 70))
                line.delete(l)
                m := true
            if _hl == "Low" and ll < line.get_y1(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = color.new(lowLineColor, 70))
                line.delete(l) 
                m := true  
    display_limit_line(_array) 
    m

remove_mitigated_boxes(_array, _hl) =>
    m = false
    if array.size(_array) > 0 and removeMitigated
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = _candleType == "Close" ? close[1] : high
            ll = _candleType == "Close" ? close[1] : low
            if _hl == "High" and hh > box.get_top(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(highBoxBgColor, 90), border_color = color.new(highBoxBorderColor, 90), border_style = highLineStyle)
                box.delete(l)
                m := true
            if _hl == "Low" and ll < box.get_top(l)
                array.remove(_array, i)
                if mitiOptions == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(lowBoxBgColor, 90), border_color = color.new(lowBoxBorderColor, 90), border_style = lowLineStyle)
                box.delete(l)
                m := true
    display_limit_box(_array) 
    m

extend_line_to_current(lineArray) =>
    if array.size(lineArray) > 0
        for i = array.size(lineArray) - 1 to 0 by 1
            l = array.get(lineArray, i)
            timeExt = time + ((time[1]-time[2])*20)
            line.set_x2(l, timeExt)

extend_box_to_current(boxArray) =>
    if array.size(boxArray) > 0
        for i = array.size(boxArray) - 1 to 0 by 1
            b = array.get(boxArray, i)
            timeExt = time + ((time[1]-time[2])*20)
            box.set_right(b, timeExt)

// ----------------------------------------------------
// Current TimeFrame
// ----------------------------------------------------
// Varibles 
// Lines
var highLineArray = array.new_line()
var lowLineArray = array.new_line()
// Boxes
var highBoxArray = array.new_box()
var lowBoxArray = array.new_box()

// Pivots
pivotHigh = ta.pivothigh(leftBars, rightBars)[1]
pivotLow = ta.pivotlow(leftBars, rightBars)[1]

// Run Calculations
if currentTF
    if pivotHigh
        if displayStyle == "Lines"
            array.push(highLineArray, line.new(time[rightBars+1],high[rightBars+1],time[+1],high[rightBars+1],color = highLineColor, style=highLineStyle, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width = lineWidth))
        else
            y1 = math.max(open[rightBars+1], close[rightBars+1])
            array.push(highBoxArray, box.new(time[rightBars+1],high[rightBars+1],time[+1],y1,bgcolor = highBoxBgColor, border_color=highBoxBorderColor, xloc=xloc.bar_time, border_style = highLineStyle, extend=extentionMax?extend.right:extend.none, border_width = lineWidth))        
    if pivotLow
        if displayStyle == "Lines"
            array.push(lowLineArray, line.new(time[rightBars+1],low[rightBars+1],time[+1],low[rightBars+1],color = lowLineColor, style=lowLineStyle, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width = lineWidth))
        else
            y1 = math.min(open[rightBars+1], close[rightBars+1])
            array.push(lowBoxArray, box.new(time[rightBars+1],low[rightBars+1],time[+1],y1,bgcolor = lowBoxBgColor, border_color=lowBoxBorderColor, xloc=xloc.bar_time, border_style = lowLineStyle, extend=extentionMax?extend.right:extend.none, border_width = lineWidth))

// ----------------------------------------------------
// Run Functions
// ----------------------------------------------------
highLineAlert = remove_mitigated_lines(highLineArray, "High")
lowLineAlert = remove_mitigated_lines(lowLineArray, "Low")
highBoxAlert = remove_mitigated_boxes(highBoxArray, "High")
lowBoxAlert = remove_mitigated_boxes(lowBoxArray, "Low")

if extentionCurrent
    extend_line_to_current(highLineArray)
    extend_line_to_current(lowLineArray)
    extend_box_to_current(highBoxArray)
    extend_box_to_current(lowBoxArray)

// Alerts
alertcondition(highLineAlert or highBoxAlert, "New High", "Price is breaking out!")
alertcondition(lowLineAlert or lowBoxAlert, "New Low", "Price is breaking down!")
//
if (highLineAlert or highBoxAlert) and alertNewHigh
    alert(alertNewHighTxt, alert.freq_once_per_bar)

if (lowLineAlert or lowBoxAlert) and alertNewLow
    alert(alertNewLowTxt, alert.freq_once_per_bar)


// ----------------------------------------------------
// Higher TimeFrame
// ----------------------------------------------------
// Varibles 
// Lines
var highLineArrayHTF = array.new_line()
var lowLineArrayHTF = array.new_line()
// Boxes
var highBoxArrayHTF = array.new_box()
var lowBoxArrayHTF = array.new_box()

// Get HTF
[_time, _open, _high, _low, _close] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close])

// Pivots
pivotHighHTF = ta.pivothigh(_high, leftBars*tf_multi(htfTF), rightBars+tf_multi(htfTF))
pivotLowHTF = ta.pivotlow(_low, leftBars*tf_multi(htfTF), rightBars+tf_multi(htfTF))

if htfBool
    timeExt = time+((time[1]-time[2])*10)
    dis = rightBars+tf_multi(htfTF)
    if pivotHighHTF
        if displayStyle == "Lines"
            array.push(highLineArrayHTF, line.new(_time[dis],_high[dis],_time[+1],_high[dis],color = highLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width = lineWidthHTF))
        else
            y1 = math.max(_open[dis], _close[dis])
            array.push(highBoxArrayHTF, box.new(_time[dis],_high[dis],_time[+1],y1,bgcolor = highBoxBgColorHTF, border_color=highBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, extend=extentionMax?extend.right:extend.none, border_width = lineWidthHTF))  
    if pivotLowHTF
        if displayStyle == "Lines"
            array.push(lowLineArrayHTF, line.new(_time[dis],_low[dis],_time[+1],_low[dis],color = lowLineColorHTF, style=lowLineStyleHTF, xloc=xloc.bar_time, extend=extentionMax?extend.right:extend.none, width = lineWidthHTF))
        else
            y1 = math.min(_open[dis], _close[dis])
            array.push(lowBoxArrayHTF, box.new(_time[dis],_low[dis],_time[+1],y1,bgcolor = lowBoxBgColorHTF, border_color=lowBoxBorderColorHTF, xloc=xloc.bar_time, border_style = lowLineStyleHTF, extend=extentionMax?extend.right:extend.none, border_width = lineWidthHTF))

// ----------------------------------------------------
// Run Functions
// ----------------------------------------------------
highLineAlertHTF = remove_mitigated_lines(highLineArrayHTF, "High")
lowLineAlertHTF = remove_mitigated_lines(lowLineArrayHTF, "Low")
highBoxAlertHTF = remove_mitigated_boxes(highBoxArrayHTF, "High")
lowBoxAlertHTF = remove_mitigated_boxes(lowBoxArrayHTF, "Low")

if extentionCurrent
    extend_line_to_current(highLineArrayHTF)
    extend_line_to_current(lowLineArrayHTF)
    extend_box_to_current(highBoxArrayHTF)
    extend_box_to_current(lowBoxArrayHTF)

// Alerts
alertcondition(highLineAlertHTF or highBoxAlertHTF, "New HTF High", "Price is breaking out!")
alertcondition(lowLineAlertHTF or lowBoxAlertHTF, "New HTF Low", "Price is breaking down!")
//
if (highLineAlertHTF or highBoxAlertHTF) and alertNewHighHTF
    alert(alertNewHighHTFTxt, alert.freq_once_per_bar)

if (lowLineAlertHTF or lowBoxAlertHTF) and alertNewLowHTF
    alert(alertNewLowHTFTxt, alert.freq_once_per_bar)

//@version=6
//indicator("CISD", "CISD", overlay = true)

//========================
// Inputs
//========================
bullishBreakColor = input.color(color.black, "Bullish", inline = "bup")
bearishBreakColor = input.color(color.black, "Bearish", inline = "bep")

bullStr = input.string("CISD", " ", tooltip = "Text to be displayed next to the bullish CISD level.", inline = "bup")
bearStr = input.string("CISD", " ", tooltip = "Text to be displayed next to the bearish CISD level.", inline = "bep")

// Fixed settings (no user inputs)
cisd_lineWidth     = 1
cisd_lookAheadBars = 5
cisd_lineStyle     = line.style_solid
cisd_keepLevels    = false

//========================
// Helpers (Body-only)
//========================
bodyHigh(offset) =>
    math.max(open[offset], close[offset])

bodyLow(offset) =>
    math.min(open[offset], close[offset])

bodySize(offset) =>
    math.abs(close[offset] - open[offset])

//========================
// Types
//========================
type MarketStructure
    float topPrice
    float bottomPrice
    bool  isBullish

type cisd
    line level
    label txt
    bool completed

//========================
// Vars
//========================
var line cisd_lastTopLine    = na
var line cisd_lastBottomLine = na

// init market structure with BODY extremes, not wicks
var MarketStructure cisd_currentStructure = MarketStructure.new(math.max(open, close), math.min(open, close), close >= open)

var cisdLevelsBu = array.new<cisd>()  // bullish CISD levels (below price usually)
var cisdLevelsBe = array.new<cisd>()  // bearish CISD levels (above price usually)

var bool  cisd_isBullishPullback   = false
var bool  cisd_isBearishPullback   = false

var float cisd_potentialTopPrice    = na   // taken from opens (body)
var float cisd_potentialBottomPrice = na   // taken from opens (body)

var int   cisd_bullishBreakIndex   = na
var int   cisd_bearishBreakIndex   = na

var bool  cisd_currentState        = false  // false = bearish, true = bullish

//========================
// Pullback Detection (body-based, with size filter)
//========================

// minimum size of pullback body vs previous body (hardcoded: 50%)
minPullbackRatio = 0.5

cisd_pullbackBody = bodySize(1)
cisd_prevBody     = bodySize(2)
cisd_validPullback = cisd_prevBody > 0 and cisd_pullbackBody >= minPullbackRatio * cisd_prevBody

// green body = bearish pullback, red body = bullish pullback, only if big enough
cisd_bearishPullbackDetected = cisd_validPullback and close[1] > open[1]
cisd_bullishPullbackDetected = cisd_validPullback and close[1] < open[1]

// Bearish Pullback Logic
if cisd_bearishPullbackDetected and not cisd_isBearishPullback
    cisd_isBearishPullback := true
    cisd_potentialTopPrice := open[1]       // body-based anchor
    cisd_bullishBreakIndex := bar_index[1]

// Bullish Pullback Logic
if cisd_bullishPullbackDetected and not cisd_isBullishPullback
    cisd_isBullishPullback    := true
    cisd_potentialBottomPrice := open[1]    // body-based anchor
    cisd_bearishBreakIndex    := bar_index[1]

// Update Potential Levels During Pullbacks (body only)
if cisd_isBullishPullback
    // New lower body → update bottom anchor
    if open < cisd_potentialBottomPrice
        cisd_potentialBottomPrice := open
        cisd_bearishBreakIndex    := bar_index
    // Red candle with higher open than current bottom → shift anchor to that open
    if (close < open) and (open > cisd_potentialBottomPrice)
        cisd_potentialBottomPrice := open
        cisd_bearishBreakIndex    := bar_index     

if cisd_isBearishPullback
    // New higher open → update top anchor
    if open > cisd_potentialTopPrice
        cisd_potentialTopPrice := open
        cisd_bullishBreakIndex := bar_index
    // Green candle with lower open than current top → shift anchor to that open
    if (close > open) and open < cisd_potentialTopPrice
        cisd_potentialTopPrice := open
        cisd_bullishBreakIndex := bar_index      

//========================
// Structure Updates - Bearish Break (BODY ONLY)
//========================
if bodyLow(0) < cisd_currentStructure.bottomPrice
    cisd_currentStructure.bottomPrice := bodyLow(0)
    cisd_currentStructure.isBullish   := false
    
    if cisd_isBearishPullback and (bar_index - cisd_bullishBreakIndex != 0)
        idxBack  = bar_index - cisd_bullishBreakIndex
        idxBack1 = idxBack + 1
        top1 = bodyHigh(idxBack)
        top2 = bodyHigh(idxBack1)
        cisd_currentStructure.topPrice := math.max(top1, top2)

        cisd_isBearishPullback := false

        cisd_bearishLine  = line.new(cisd_bullishBreakIndex, cisd_potentialTopPrice, bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, color = bullishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bearishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, bullStr, color = color.new(color.white, 100), textcolor = bullishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bstruct = cisd.new(cisd_bearishLine, cisd_bearishLabel, false)
        array.push(cisdLevelsBe, cisd_bstruct)
    else if close[1] > open[1] and close < open
        cisd_currentStructure.topPrice := bodyHigh(1)
        cisd_isBearishPullback := false

        cisd_bearishLine  = line.new(cisd_bullishBreakIndex, cisd_potentialTopPrice, bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, color = bullishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bearishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, bullStr, color = color.new(color.white, 100), textcolor = bullishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bstruct = cisd.new(cisd_bearishLine, cisd_bearishLabel, false)
        array.push(cisdLevelsBe, cisd_bstruct)

//========================
// Structure Updates - Bullish Break (BODY ONLY)
//========================
if bodyHigh(0) > cisd_currentStructure.topPrice
    cisd_currentStructure.isBullish := true
    cisd_currentStructure.topPrice  := bodyHigh(0)
    
    if cisd_isBullishPullback and (bar_index - cisd_bearishBreakIndex != 0)
        idxBack  = bar_index - cisd_bearishBreakIndex
        idxBack1 = idxBack + 1
        bot1 = bodyLow(idxBack)
        bot2 = bodyLow(idxBack1)
        cisd_currentStructure.bottomPrice := math.min(bot1, bot2)

        cisd_isBullishPullback := false

        cisd_bullishLine  = line.new(cisd_bearishBreakIndex, cisd_potentialBottomPrice, bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, color = bearishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bullishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, bearStr, color = color.new(color.white, 100), textcolor = bearishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bu_struct = cisd.new(cisd_bullishLine, cisd_bullishLabel, false)
        array.push(cisdLevelsBu, cisd_bu_struct)
    else if close[1] < open[1] and close > open
        cisd_currentStructure.bottomPrice := bodyLow(1)
        cisd_isBullishPullback := false

        cisd_bullishLine  = line.new(cisd_bearishBreakIndex, cisd_potentialBottomPrice, bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, color = bearishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bullishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, bearStr, color = color.new(color.white, 100), textcolor = bearishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bu_struct = cisd.new(cisd_bullishLine, cisd_bullishLabel, false)
        array.push(cisdLevelsBu, cisd_bu_struct)

//========================
// Level cleanup (keep latest only)
//========================
if array.size(cisdLevelsBu) > 1 and not cisd_keepLevels
    cisd_oldestBu = array.shift(cisdLevelsBu)
    line.delete(cisd_oldestBu.level)
    label.delete(cisd_oldestBu.txt)

if array.size(cisdLevelsBe) > 1 and not cisd_keepLevels
    cisd_oldestBe = array.shift(cisdLevelsBe)
    line.delete(cisd_oldestBe.level)
    label.delete(cisd_oldestBe.txt)

//========================
// Manage bullish CISD (below price)
//========================
if array.size(cisdLevelsBu) >= 1
    cisd_latestBuIndex = array.size(cisdLevelsBu) - 1
    cisd_latestBu      = array.get(cisdLevelsBu, cisd_latestBuIndex)

    // As long as body low is not below CISD, extend the line
    if not (bodyLow(0) < cisd_latestBu.level.get_y2()) and not cisd_latestBu.completed
        line.set_x2(cisd_latestBu.level, bar_index + cisd_lookAheadBars)
        label.set_x(cisd_latestBu.txt, bar_index + cisd_lookAheadBars)

    // Break: body low closes below CISD
    if bodyLow(0) < cisd_latestBu.level.get_y2() and not cisd_latestBu.completed
        cisd_latestBu.completed := true
        array.set(cisdLevelsBu, cisd_latestBuIndex, cisd_latestBu)

        // Spawn new bearish CISD from current top anchor
        cisd_bearishLine  = line.new(cisd_bullishBreakIndex, cisd_potentialTopPrice, bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, color = bullishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bearishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialTopPrice, bullStr, color = color.new(color.white, 100), textcolor = bullishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bstruct2 = cisd.new(cisd_bearishLine, cisd_bearishLabel, false)
        array.push(cisdLevelsBe, cisd_bstruct2)

        cisd_currentState := false

//========================
// Manage bearish CISD (above price)
//========================
if array.size(cisdLevelsBe) >= 1
    cisd_latestBeIndex = array.size(cisdLevelsBe) - 1
    cisd_latestBe      = array.get(cisdLevelsBe, cisd_latestBeIndex)

    // As long as body high is not above CISD, extend the line
    if not (bodyHigh(0) > cisd_latestBe.level.get_y2()) and not cisd_latestBe.completed
        line.set_x2(cisd_latestBe.level, bar_index + cisd_lookAheadBars)
        label.set_x(cisd_latestBe.txt, bar_index + cisd_lookAheadBars)

    // Break: body high closes above CISD
    if bodyHigh(0) > cisd_latestBe.level.get_y2() and not cisd_latestBe.completed
        cisd_latestBe.completed := true
        array.set(cisdLevelsBe, cisd_latestBeIndex, cisd_latestBe)

        // Spawn new bullish CISD from current bottom anchor
        cisd_bullishLine  = line.new(cisd_bearishBreakIndex, cisd_potentialBottomPrice, bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, color = bearishBreakColor, width = cisd_lineWidth, style = cisd_lineStyle)
        cisd_bullishLabel = label.new(bar_index + cisd_lookAheadBars, cisd_potentialBottomPrice, bearStr, color = color.new(color.white, 100), textcolor = bearishBreakColor, style = label.style_label_left, size = size.small)
        cisd_bu_struct2 = cisd.new(cisd_bullishLine, cisd_bullishLabel, false)
        array.push(cisdLevelsBu, cisd_bu_struct2)

        cisd_currentState := true
// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/
// © LuxAlgo


//indicator("Liquidity Voids (FVG) [LuxAlgo]", "LuxAlgo - Liquidity Voids (FVG)", overlay = true, max_boxes_count = 500)

//------------------------------------------------------------------------------
// Settings
//-----------------------------------------------------------------------------{

mdTT = 'The mode option controls the number of visual objects presented, where\n\n- Historical, takes into account all data available to the user\n- Present, takes into account only the last X bars specified in the \'# Bars\' option'
mode = input.string('Historical', title = 'Mode', options =['Present', 'Historical'], inline = 'MOD')
back = input.int   (360, ' # Bars', minval = 100, maxval = 5000, step = 10, inline = 'MOD', tooltip = mdTT)

lqGR = 'Liquidity Detection'
lqTT = 'Act as a filter while detecting the Liquidity Voids. When set to 0 means no filtering is applied, increasing the value causes the script to check the width of the void compared to a fixed-length ATR value'
lqTH = input.float(.5, 'Liquidity Voids Threshold', minval = 0, step = .1, group = lqGR, tooltip = lqTT)
lqBC = input.color(color.new(#089981, 73), 'Bullish', inline = 'VD', group = lqGR)
lqSC = input.color(color.new(#f23645, 73), 'Bearish', inline = 'VD', group = lqGR)
lqTX = input.bool (false, 'Label', inline = 'VD', group = lqGR)

lqFT = 'Toggles the visibility of the Filled Liquidity Voids'
lqVF = input.bool (true, 'Filled Liquidity Voids', inline = 'FL', group = lqGR, tooltip = lqFT)
lqFC = input.color(color.new(#787b86, 73), '', inline = 'FL', group = lqGR)

//-----------------------------------------------------------------------------}
// User Defined Types
//-----------------------------------------------------------------------------{

// @type        bar properties with their values 
//
// @field h     (float) high price of the bar
// @field l     (float) low price of the bar
// @field c     (float) close price of the bar
// @field i     (int) index of the bar

type bar
    float h = high
    float l = low
    float c = close
    int   i = bar_index

//-----------------------------------------------------------------------------}
// Variables
//-----------------------------------------------------------------------------{

bar lux_b = bar.new()
var lqV = array.new_box()

//-----------------------------------------------------------------------------}
// Calculations
//-----------------------------------------------------------------------------{

per = mode == 'Present' ? last_bar_index - lux_b.i <= back : true
atr = ta.atr(144) * lqTH

if per
    bull = (lux_b.l - lux_b.h[2]) > atr and lux_b.l > lux_b.h[2] and lux_b.c[1] > lux_b.h[2]

    if bull 
        lq_len = 13
        if bull[1] 
            st = math.abs(lux_b.l - lux_b.l[1]) / lq_len
            for i = 0 to lq_len - 1
                array.push(lqV, box.new(lux_b.i - 2, lux_b.l[1] + (i + 1) * st, lux_b.i, lux_b.l[1] + i * st, na, bgcolor = lqBC ))
        else   
            st = math.abs(lux_b.l - lux_b.h[2]) / lq_len
            for i = 0 to lq_len - 1
                if lqTX and i == 0
                    array.push(lqV, box.new(lux_b.i - 2, lux_b.h[2] + (i + 1) * st, lux_b.i, lux_b.h[2] + i * st, na, text = 'Liquidity Void   ', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_bottom, text_color = na, bgcolor = lqBC ))
                else
                    array.push(lqV, box.new(lux_b.i - 2, lux_b.h[2] + (i + 1) * st, lux_b.i, lux_b.h[2] + i * st, na, bgcolor = lqBC ))

    bear = (lux_b.l[2] - lux_b.h) > atr and lux_b.h < lux_b.l[2] and lux_b.c[1] < lux_b.l[2]

    if bear
        lq_len = 13
        if bear[1]
            st = math.abs(lux_b.h[1] - lux_b.h) / lq_len
            for i = 0 to lq_len - 1
                array.push(lqV, box.new(lux_b.i - 2, lux_b.h + (i + 1) * st, lux_b.i, lux_b.h + i * st, na, bgcolor = lqSC ))
        else
            st = math.abs(lux_b.l[2] - lux_b.h) / lq_len
            for i = 0 to lq_len - 1
                if lqTX and i == lq_len - 1
                    array.push(lqV, box.new(lux_b.i - 2, lux_b.h + (i + 1) * st, lux_b.i, lux_b.h + i * st, na, text = 'Liquidity Void   ', text_size = size.tiny, text_halign = text.align_right, text_valign = text.align_top, text_color = na, bgcolor = lqSC ))
                else
                    array.push(lqV, box.new(lux_b.i - 2, lux_b.h + (i + 1) * st, lux_b.i, lux_b.h + i * st, na, bgcolor = lqSC ))

if lqV.size() > 0
    qt = lqV.size()

    for bn = qt - 1 to 0
        if bn < lqV.size()
            cb = lqV.get(bn)
            tBX = cb.get_top()
            bBX = cb.get_bottom()
            if lux_b.h > bBX and lux_b.l < tBX
                if lqVF
                    cb.set_bgcolor(lqFC)
                else
                    cb.delete()
                lqV.remove(bn)
            else
                cb.set_right(lux_b.i + 1)

                if lux_b.i - cb.get_left() > 21
                    cb.set_text_color(chart.fg_color)

    if lqV.size() > 500
        lqV.shift()
//-----------------------------------------------------------------------------}